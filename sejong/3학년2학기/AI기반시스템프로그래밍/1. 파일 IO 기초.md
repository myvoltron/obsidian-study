# 1. 개론 (Introduction)
## 1.1 파일 I/O란 무엇인가?
파일 I/O는 **프로세스와 파일 시스템 간의 데이터 교환**을 의미합니다.
- **유닉스 철학**: "**모든 것은 파일이다**". 일반 파일, 디바이스, 파이프, 소켓 등을 모두 파일로 다룹니다.
- **핵심 시스템 호출**: `open()`, `read()`, `write()`, `close()`입니다.
- 고수준 입출력 (`fread()`, `fwrite()` 등)은 결국 이 저수준 시스템 호출 위에 구현됩니다.
## 버퍼링 개념 (Buffering Concepts)
입출력 성능을 향상시키기 위해 데이터를 한 번에 모아서 처리하는 방식입니다. 이는 CPU와 HDD 간의 속도 차이가 매우 크기 때문에 발생합니다 (CPU 레지스터: $1\text{ns}$ 수준, HDD: 수 $\text{ms}$ 수준, 약 1,000만 배 차이).
- **사용자 공간 버퍼링 (User-space Buffering)**:
    - `fopen()`, `fwrite()`, `fread()` 등 **고수준 I/O**에서 동작합니다.
    - `FILE*` 구조체 내부에 버퍼를 유지하며 , `fwrite()`는 즉시 `write()`를 호출하지 않고 내부 버퍼에 데이터를 모아둡니다.
    - 버퍼가 가득 차거나 `fflush()` 호출 시 시스템 호출(syscall)이 발생합니다.
- **커널 공간 버퍼링 (Kernel-space Buffering)**:
    - `read()`, `write()` 등 **저수준 I/O** 호출 시 **커널 페이지 캐시**를 사용합니다.
    - 데이터는 일단 메모리 상의 커널 캐시에 기록되며, 실제 디스크 접근은 지연될 수 있습니다.
    - 캐시 플러시(flush) 시점은 커널 스케줄러에 의해 결정되거나, `fsync()`, `fdatasync()`, `sync()` 호출로 강제할 수 있습니다.
## 파일 I/O에서의 원자적 연산 (Atomic Operation)
**Atomic Operation**은 분할되지 않고 중간에 끼어들 수 없는 연산을 의미합니다.
- **문제점**: `lseek(fd, offset, SEEK_SET);`와 `write(fd, buf, n);`를 별도로 호출하는 경우, 중간에 다른 스레드나 시그널 핸들러가 동일한 **파일 오프셋**을 변경하여 예상치 못한 위치에 쓰기가 발생할 수 있습니다 (TOCTTOU 취약점 발생 가능).
- **해결책**: `pread()` / `pwrite()` 사용.
    - **오프셋 지정 + I/O**를 한 번에 처리하여 **원자적 연산**으로 만듭니다.
    - 내부적으로 `lseek()` 호출 없이 동작하며, 스레드와 무관하게 항상 같은 위치에 읽고 쓰기가 가능합니다.
    - 함수 시그니처:
        - `ssize_t pread(int fd, void *buf, size_t nbytes, off_t offset);` 
        - `ssize_t pwrite(int fd, const void *buf, size_t nbytes, off_t offset);` 
# 2. 파일 디스크립터 및 파일 열기 (File Descriptor & Opening Files)
## 파일 디스크립터란 무엇인가?
- 커널 관점에서, 모든 열린 파일은 **파일 디스크립터**(FD)라는 **음이 아닌 정수 값**으로 식별됩니다.
- `open()` 또는 `creat()` 호출 성공 시 커널이 이 값을 반환하며, 이후 `read()`, `write()` 등에서 파일을 지정하는 데 사용됩니다.
- **유효한 FD 범위**: 0부터 `OPEN_MAX - 1`까지이며, `OPEN_MAX` 값은 시스템마다 다릅니다.
- 표준 파일 디스크립터:

| 번호  | 의미    | 매크로 상수 이름     |
| --- | ----- | ------------- |
| 0   | 표준 입력 | STDIN_FILENO  |
| 1   | 표준 출력 | STDOUT_FILENO |
| 2   | 표준 에러 | STDERR_FILENO |

### `open()`, `openat()`
파일을 열고 FD를 반환하는 시스템 호출입니다.
- **함수 시그니처**:
    - `int open(const char *path, int oflag, ... /* mode_t mode */);` 
    - `int openat(int dirfd, const char *path, int oflag, ... /* mode_t mode */);` 
- **인수**:
    - `path`: 파일 경로 
    - `oflag`: 접근 모드 및 옵션 (`O_RDONLY`, `O_WRONLY`, `O_CREAT` 등) 
		- `O_RDONLY`, `O_WRONLY`, `O_RDWR`: Required
		- `O_CREAT`: 파일 없으면 생성 -> `mode` 인자 필요
		- `O_TRUNC`: 열 때 파일 기존 내용 제거
		- `O_APPEND`: 쓸 때 파일 끝 부분부터 씀
		- `O_EXCL`: `O_CREAT`와 함께 쓸 때, 파일 존재 시 에러 반환
    - `mode`: `O_CREAT` 시 새 파일의 권한 지정 (umask 적용) 
    - `dirfd` (`openat` 전용): 기준 디렉터리 FD (현재 디렉터리: `AT_FDCWD`) 
- **`openat()` 특징**: 특정 디렉터리 FD를 기준으로 경로를 해석합니다.
	- fd + 절대주소: fd를 무시하고 절대주소로 해석
	- **AT_FDCWD** + 상대주소: 현재 디렉터리 기준으로 상대주소 해석
    - 주요 사용 목적은 **멀티스레드 환경에서 작업 디렉터리가 바뀌는 오류를 방지**하고, **TOCTTOU 취약점을 방지**하기 위함입니다.
### `creat()`, `close()`
- **`creat()`**: 새로운 파일 생성 전용 시스템 콜 (초기 UNIX 도입).
    - 현재는 `open(pathname, O_WRONLY | O_CREAT | O_TRUNC, mode)`와 동일하며, `open()`이 `O_CREAT`를 지원하면서 사실상 대체됨.
- **`close()`**: 열린 파일 디스크립터를 닫아 커널 리소스를 해제
    - 참조 카운트가 0이 되면 실제 파일 테이블 엔트리가 해제
    - 함수 시그니처: `int close(int fd);` 
# 3. 위치 지정 및 기본 I/O (Positioning & Basic I/O)
## `lseek()`
열린 파일의 **현재 파일 오프셋**(current offset)을 이동시킵니다.
- 실제 I/O는 발생하지 않고 커서만 이동합니다.
- **함수 시그니처**: `off_t lseek(int fd, off_t offset, int whence);` 
- **`whence` (기준 위치)**:
    - `SEEK_SET`: 파일 시작 기준 
    - `SEEK_CUR`: 현재 위치 기준
    - `SEEK_END`: 파일 끝 기준
- **특징**: 파일 끝보다 먼 위치로 이동 후 쓰기를 하면 중간 영역이 0으로 채워진 **hole 파일**(희소 파일)이 생성될 수 있습니다.
## `read()`
열린 파일 FD에서 최대 `nbytes`만큼 데이터를 읽어 `buf`에 저장합니다.
- 파일의 현재 오프셋에서 읽기 시작하며, 읽은 바이트 수만큼 오프셋이 증가합니다.
- **함수 시그니처**: `ssize_t read(int fd, void *buf, size_t nbytes);` 
- **반환값**: 실제 읽은 바이트 수 ($\ge 0$), EOF(파일 끝)이면 0, 오류 시 -1.
## `write()`
버퍼(`buf`)의 내용을 파일에 최대 `nbytes`만큼 기록합니다.
- 파일의 현재 오프셋에서 쓰기 시작하며, 쓴 바이트 수만큼 오프셋이 증가합니다.
- `O_APPEND` 옵션이 설정된 경우, 항상 파일 끝에 추가됩니다.
- **함수 시그니처**: `ssize_t write(int fd, const void *buf, size_t nbytes)` 
- **반환값**: 실제로 쓴 바이트 수 ($\ge 0$), 오류 시 -1.
# 4. 디스크립터 복제 및 공유 (Descriptor Duplication & Sharing)
## UNIX 파일 공유 구조
UNIX는 파일을 여러 프로세스 간에 공유할 수 있도록 지원하며, 커널 내부의 3단계 데이터 구조를 통해 관리됩니다.
1. **프로세스 테이블 엔트리 (Process Table Entry)**:
    - 각 프로세스마다 자신만의 파일 디스크립터 테이블을 가집니다.
    - 포함 정보: **FD 플래그**, **파일 테이블 엔트리 포인터**.
	    - `FD_CLOEXEC`: `exec` 시 자동으로 `close`
2. **파일 테이블 엔트리 (File Table Entry)**:
    - 하나의 `open()` 호출마다 새로 생성되는 커널의 공통 테이블입니다.
    - 포함 정보: **파일 상태 플래그** (`O_RDONLY`, `O_WRONLY` 등), **현재 오프셋**, **v-node 포인터**.
    - `dup()`, `fork()` 등으로 여러 프로세스가 하나의 엔트리를 가리킬 수 있습니다.
3. **V-node / I-node**:
    - **V-node**: 파일 시스템 독립적 구조체 (BSD/Solaris 계열).
    - **I-node**: 실제 파일의 메타정보 저장 (크기, 소유자, 디스크 블록 등).
    - Linux는 일반화된 i-node 구조를 사용합니다.
- **독립적인 `open()`**: 두 프로세스가 같은 파일을 각자 `open()`한 경우, 각각 다른 **파일 테이블 엔트리**를 가지므로 **파일 오프셋이 독립적**입니다. **V-node/i-node는 공유**됩니다.
## `dup()`, `dup2()`
기존 FD를 복제하여 같은 파일 테이블 엔트리를 가리키게 합니다.
- **`dup(oldfd)`**: 커널이 **가장 낮은 사용 가능한 번호**를 새 FD로 선택합니다.
- **`dup2(oldfd, newfd)`**: **`newfd` 번호를 명시적 지정** 가능하며, `newfd`가 이미 열려 있으면 **자동으로 `close()` 후 재사용**하는 원자적 연산을 수행합니다.
- 두 FD는 **오프셋과 파일 상태 플래그를 공유**합니다.
- 새 FD의 디스크립터 플래그(`FD_CLOEXEC`)는 기본적으로 해제. 필요시 `fcntl(F_SETFD)`사용
# 5. 동기화 및 제어 (Synchronization & Control)
## `sync()`, `fsync()`, `fdatasync()`
`write()` 호출 시 커널 버퍼에만 기록되므로, 실제 디스크 기록을 강제하기 위한 함수들입니다.

| **함수**          | **범위** | **기록 대상**            | **동작 방식**                        |
| --------------- | ------ | -------------------- | -------------------------------- |
| `sync()`        | 시스템 전체 | 모든 dirty buffer/page | **요청만**, 즉시 리턴 (기록 완료까지 기다리지 않음) |
| `fsync(fd)`     | 특정 파일  | **데이터 + 메타데이터**      | **완료까지 대기** (안전한 기록)             |
| `fdatasync(fd)` | 특정 파일  | **데이터 (필수 메타 제외)**   | **완료까지 대기** (`fsync`보다 빠름)       |
## `fcntl()` (File Control)
이미 열린 파일 디스크립터의 속성을 제어하는 **만능 리모컨 같은 함수**입니다.
- **함수 시그니처**: `int fcntl(int fd, int cmd, ... /* arg */);` 
- **주요 `cmd`**:
    - **FD 복제**: `F_DUPFD`, `F_DUPFD_CLOEXEC` (dup, dup2와 유사)
    - **FD 플래그**: `F_GETFD`, `F_SETFD` (`FD_CLOEXEC` 조회/설정) 
    - **파일 상태 플래그**: `F_GETFL`, `F_SETFL`  
        - 접근 모드 (`O_RDONLY` 등)는 조회만 가능하며 설정은 불가합니다.
	- **비동기 I/O 소유권**: `F_GETOWN`, `F_SETOWN` (시그널 받을 프로세스/프로세스 그룹 지정)
## `ioctl()` (I/O Control)
입출력 장치나 파일 디스크립터에 대한 **저수준 제어 기능**을 제공하며, 장치 종속적인 제어에 주로 사용됩니다.
## `/dev/fd`
`/dev/fd/n`은 **n번째 파일 디스크립터**를 나타내는 경로입니다.
- `0`: stdin, `1`: stdout, `2`: stderr.
- 일반 경로처럼 취급하여 표준 입력(`-`)을 파일처럼 다룰 수 있습니다.