# 1. 프로그램 시작 및 종료
## 프로그램 시작
- **`main` 함수**: `int main(int argc, char *argv[])` 형태로 정의됩니다.
    - `argc`: 인자의 개수 (argument count), 프로그램 이름 포함.
    - `argv`: 인자 문자열의 배열 (argument vector), `argv[0]`는 프로그램 이름, `argv[1]`부터 실제 인자이며, `argv[argc]`는 `NULL` 포인터로 끝납니다.
	    - 인자는 셸에서 **공백으로 구분**되어 전달됨.
- **시작 루틴**: `main()` 함수가 호출되기 전에 **start-up routine**(`libc_start_main` 등)이 먼저 호출되어, 커널이 인자와 환경 변수를 메모리 상에 설정합니다.
## 프로그램 종료
### 프로세스 정상 종료 방식 (5가지)
- `main()` 함수에서 `return` (== `exit()` 방식과 동일)
- `exit(status)` 호출 (ISO C)
	- `atexit()` 핸들러 실행 + stdio **버퍼 flush**
- `_exit(status)` 또는 `_Exit(status)` 호출
	- 버퍼 flush 없이 **즉시 종료**
	- `exit()` 내부에서 `_exit()` 호출
- **마지막 스레드**가 `main()`에서 `return` 
- 마지막 스레드가 `pthread_exit()` 호출
### 비정상 종료 방식 (3가지)
- `abort()` 호출 -> `SIGABRT` 시그널 발생
- 시그널 수신 (`SIGSEGV`, `SIGFPE`)
	- SEGV: Segmentation Violation
	- FPE: Floating Point Exception
- **스레드 취소 요청** 수락 (pthread_cancel)
### `atexit()`
- `int atexit(void (*func)(void))` 함수를 사용하여 `exit()` 호출 시 실행할 함수를 등록합니다.
    - 등록된 함수들은 **등록된 역순으로** 실행됩니다.
    - 인수가 없고 반환 값이 없는 함수만 등록 가능합니다.
# 2. 환경 변수 및 명령줄
## 환경 목록 (Environment List)
- 환경 변수는 **`KEY=VALUE`** 형태의 문자열로 구성됩니다.
- **접근**: 전역 변수 `extern char **environ`을 통해 접근 가능하며, `main` 함수의 세 번째 인자 (`char *envp[]`)로도 전달됩니다.
- **상속**: 부모 프로세스의 환경은 **자식 프로세스로 자동 전달**됩니다.
- **저장 위치**: 프로세스 메모리 공간의 상단, **스택보다 위**에 저장됩니다.
## 환경 변수 관리 함수

| **함수**                               | **역할**                                  |
| ------------------------------------ | --------------------------------------- |
| `char *getenv(name)`                 | 환경 변수 **값**을 얻어옴 (없으면 `NULL` 반환).       |
| `int setenv(name, value, overwrite)` | 환경 변수 설정 또는 갱신 (overwrite=0이면 기존 값 유지). |
| `int unsetenv(name)`                 | 환경 변수 제거.                               |
| `int putenv(string)`                 | `"name=value"` 형식 문자열을 환경 변수로 설정.       |
- **메모리 관리**: 환경 변수 목록 수정은 복잡하며, 새 값을 추가하거나 기존 값을 늘릴 경우 `malloc`을 사용해 메모리를 재할당해야 합니다.
	- 추가하는 경우, 처음엔 `malloc`으로 새로운 영역을 마련하고, 기존 환경 변수 목록을 새 영역에 복사 -> 이후 또 추가할 땐 `realloc` 사용
# 3. 메모리 할당
## C 프로그램 메모리 배치
프로세스 메모리 공간은 다음 영역으로 나뉩니다:
- **Text 영역**: 실행 코드 저장.
- **Data 영역**: 초기화된 전역 및 정적 변수 저장.
- **BSS 영역**: 초기화되지 않은 전역 및 정적 변수 저장 (실행 시 0으로 초기화).
- **Heap 영역**: `malloc`, `calloc` 등 **동적 할당** 시 확장.
- **Stack 영역**: 함수 호출 시 지역 변수와 리턴 주소 저장.
- **명령줄 인자/환경 변수**: 스택보다 높은 주소에 위치.
## Shared library
- 여러 프로그램이 **동시에 사용할 수 있는 객체 코드 집합**
- 보통 `.so` 확장자를 가지며, 실행 시 연결됨
- 시스템 라이브러리 대부분이 공유 라이브러리로 구성됨
### Static linking vs Dynamic linking
- **Static linking**: 필요한 라이브러리 전부 통합
	- 다른 운영체제에서도 쓸 수 있다.
- **Dynamic linking**: 라이브러리 링크만 통합 (Default 동작)
	- 따라서 실행 시점에 **동적 로더**가 `.so`를 메모리에 붙임
## 동적 메모리 할당
할당된 메모리는 **Heap 영역**에 위치하며, **연속된 공간**이며 **정렬을 만족**합니다.
- `void *malloc(size_t size)`: 지정한 크기의 메모리 할당 (내용 초기화되지 않음).
- `void *calloc(size_t nobj, size_t size)`: `nobj`개의 객체 할당 후 **메모리 내용을 0으로 초기화**.
- `void *realloc(void *ptr, size_t size)`: 기존 메모리 블록 크기 재조정. **새 주소가 할당될 수 있어** 반환 포인터를 다시 저장해야 합니다.
- `void free(void *ptr)`: 동적 메모리를 **명시적으로 해제**해야 메모리 누수가 발생하지 않습니다.
# 4. 비지역 점프 (`setjmp`/`longjmp`)
C언어의 `goto`는 같은 함수 내에서만 점프 가능하지만 , `setjmp`/`longjmp`를 사용하면 **함수 간 점프** (비지역 점프)를 수행하여 에러 핸들링에 활용할 수 있습니다.
- `int setjmp(jmp_buf env)`: 현재 **스택 상태** (레지스터, 스택 포인터 등)를 `env`에 저장합니다. 직접 호출 시 **0**을 반환합니다.
- `void longjmp(jmp_buf env, int val)`: 이전에 `setjmp`로 저장한 지점으로 점프하며, `setjmp`의 **반환값을 `val`로 설정**합니다.
- **변수 복구**: `longjmp` 호출 시, 대부분의 구현은 **자동 변수와 레지스터 변수**를 원래대로 복원합니다.
    - **`volatile`** 변수: 값이 외부에서 변경될 수 있음을 컴파일러에게 알려 **최적화를 금지**하고, `longjmp` 이후에도 **값이 유지**되도록 강제합니다.
    - **전역/정적 변수**: 스택 영역에 저장되지 않으므로 값이 유지됩니다.
    - **자동 변수**: 최적화 X -> 유지, 최적화 O -> 복원
# 5. 자원 제한 (Resource Limits)
- **자원 제한**: 각 프로세스가 커널로부터 부여받는 자원 사용의 한계이며, 부모-자식 프로세스 간에 **상속**됩니다.
- **제한 유형**:
    - **Soft limit (`rlim_cur`)**: 현재 한계. hard limit 이하로 변경 가능.
    - **Hard limit (`rlim_max`)**: 최대 한도. soft limit 이상으로 감소 가능.
- **관리 함수**:
    - `int getrlimit(resource, rlptr)`: 지정된 리소스의 soft/hard limit을 가져옵니다.
    - `int setrlimit(resource, rlptr)`: 리소스의 soft/hard limit을 변경합니다.
- **변경 규칙**: 일반 사용자는 hard limit을 **감소**만 시킬 수 있으며, hard limit을 **증가**시키려면 **root 권한**이 필요합니다.
    - **무한대 설정**: `RLIM_INFINITY`를 사용합니다.
- **주요 제한 항목**: `RLIMIT_AS` (가용 메모리), `RLIMIT_CORE` (코어 파일 크기), `RLIMIT_FSIZE` (생성 가능한 파일 최대 크기), `RLIMIT_NOFILE` (열 수 있는 최대 파일 수), `RLIMIT_NPROC` (최대 자식 프로세스 수), `RLIMIT_STACK` (스택 최대 크기) 등이 있습니다.