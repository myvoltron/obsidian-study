# 1. 터미널 및 네트워크 로그인
## 로그인 프로세스 흐름 (BSD 스타일)
UNIX 시스템에서 사용자 로그인은 `init` 프로세스(PID 1)에서 시작되어 일련의 `fork()`와 `exec()` 과정을 거칩니다.
1. **`init` (PID 1)**: `/etc/ttys` 파일을 읽고, 로그인 가능한 각 터미널마다 `fork()` 후 **`getty`** 프로그램을 `exec()`합니다.
2. **`getty`**: 해당 터미널을 `open`하고 (FD 0, 1, 2를 터미널 장치에 연결) 사용자 이름 입력을 받은 후 , **`login`** 프로그램을 `exec()`합니다.
3. **`login`**: 사용자 정보 조회, 비밀번호 입력 및 검증을 수행합니다.
    - **인증 성공 시**: 홈 디렉터리로 이동 (`chdir`), 터미널 소유권/권한 변경 (`chown`, `setgid`), 환경 변수 설정, **사용자 ID로 전환 (`setuid`)** 후 **로그인 셸**을 `exec()`합니다.
## 네트워크 로그인
물리적 연결 대신 네트워크 요청(예: TELNET)을 통해 로그인합니다.
- **`inetd` (Internet superserver)**: `init`으로부터 실행되어 네트워크 연결 요청을 대기합니다.
- **연결 발생 시**: `inetd`가 `fork()` 후 **`telnetd`**를 `exec()`합니다 `telnetd`는 다시 **pseudo terminal**을 열고 `login` 프로그램을 실행시킵니다.
- **FD 연결**: 파일 디스크립터 0, 1, 2는 pseudo terminal에 연결됩니다.
# 2. 프로세스 그룹과 세션
## 프로세스 그룹 (Process Groups)
**관련된 작업 단위**를 묶은 프로세스들의 집합입니다.
- **목적**: 하나의 터미널에서 **동일한 시그널**을 수신할 수 있도록 합니다.
- **그룹 리더**: **PID와 PGID가 동일한** 프로세스이며, 그룹을 생성합니다.
- **그룹 ID 관리**:
    - `pid_t getpgrp(void)`: 호출 프로세스의 그룹 ID 반환.
    - `int setpgid(pid, pgid)`: `pid` 프로세스를 `pgid` 그룹에 포함시킵니다.
## 세션 (Sessions)
**하나 이상의 프로세스 그룹**으로 구성된 집합입니다.
- **세션 생성**: `pid_t setsid(void)`를 호출하면 호출 프로세스가 **새로운 세션 리더** 및 **새로운 프로세스 그룹 리더**가 됩니다. 일반적으로 `fork` 후 자식이 호출합니다.
- **세션 ID 조회**: `pid_t getsid(pid)`: 특정 PID의 세션 리더의 PGID(즉, 세션 ID)를 반환합니다.
## 컨트롤링 터미널 (Controlling Terminal)
세션은 하나의 터미널 장치를 **제어용**으로 가질 수 있습니다 (예: `/dev/tty1`, `/dev/pts/0`).
- **포그라운드/백그라운드 그룹**:
    - 한 세션은 1개의 **포그라운드 프로세스 그룹**과 다수의 **백그라운드 프로세스 그룹**을 가집니다.
    - 터미널에서 발생하는 입력과 시그널 (Ctrl+C, Ctrl+Z 등)은 **포그라운드 그룹**에만 전달됩니다.
- **`/dev/tty`**: 입출력 리디렉션 여부와 관계없이 **자신이 사용하는 컨트롤링 터미널**을 참조하는 특수 파일입니다.
## 포그라운드 그룹 제어 함수
주로 셸(shell)이 작업 제어(Job Control)를 위해 사용합니다.
- `pid_t tcgetpgrp(int fd)`: 해당 터미널의 **포그라운드 프로세스 그룹 ID**를 반환합니다.
- `int tcsetpgrp(int fd, pid_t pgrpid)`: 해당 터미널의 **포그라운드 프로세스 그룹을 설정**합니다.
- **셸의 동작**: 셸은 `fork()` 후 자식을 새 그룹으로 묶고, `tcsetpgrp()`로 자식 그룹을 포그라운드로 지정합니다. 실행 완료 후 셸은 다시 자신의 그룹을 포그라운드로 지정하여 제어권을 가져옵니다.
# 3. 작업 제어 및 고아 그룹
## 작업 제어 (Job Control)
여러 작업을 백그라운드/포그라운드로 실행하고 제어하는 기능입니다.
- **주요 시그널**:
    - `SIGINT` (Ctrl+C): 프로세스 종료.
    - `SIGQUIT` (Ctrl+): 프로세스 종료 + 코어 덤프.
    - `SIGTSTP` (Ctrl+Z): 프로세스 일시 정지 (Stop).
- **터미널 접근 시그널**:
    - `SIGTTIN`: 백그라운드 프로세스가 터미널 입력(`stdin`)을 읽으려 할 때 발생 (기본 동작: 정지).
    - `SIGTTOU`: 백그라운드 프로세스가 터미널 출력(`stdout`/`stderr`)을 시도할 때 발생 (기본 동작: 정지).
- **셸 명령어**: `fg %N` (포그라운드 복귀), `bg %N` (백그라운드 재개), `jobs -l` (현재 실행 중인 작업 목록).
## 셸 유형별 비교

| **기능**              | **Bourne Shell (sh)**   | **Bash Shell (bash)**  |
| ------------------- | ----------------------- | ---------------------- |
| **Job Control**     | 없음                      | 있음                     |
| **PGID**            | 셸과 동일한 PGID 사용          | **별도 PGID 생성**         |
| **터미널 제어**          | SIGINT/SIGTSTP 등 전체에 전달 | **foreground 그룹에만 전달** |
| **SIGTTIN/SIGTTOU** | 발생하지 않음                 | 발생 (프로세스 정지)           |
## 고아 프로세스 그룹 (Orphaned Process Groups)
- **정의**: 그룹 내의 **부모 프로세스들이 모두 종료**되어, 그룹 리더를 포함한 프로세스들이 `init`의 자식이 된 상태입니다.
- **처리**: POSIX.1에서는 고아가 된 프로세스 그룹의 모든 프로세스에 **`SIGHUP`** (연결 끊김)과 **`SIGCONT`** (계속 실행)를 차례로 발생시키도록 요구합니다.
    - `SIGHUP`의 기본 동작은 프로세스 종료입니다.
- **실제 활용**: 데몬 프로세스가 터미널에 묶이지 않고 독립적으로 실행될 때 이 메커니즘을 이용합니다.