# 1. 스트림과 `FILE` 구조체
## 파일 디스크립터 vs 스트림
표준 I/O 라이브러리는 저수준의 파일 디스크립터(FD)를 추상화한 **스트림(Stream)**을 사용합니다.

| **항목**    | **File Descriptor (fd)**  | **Stream (FILE *)**         |
| --------- | ------------------------- | --------------------------- |
| **기반**    | UNIX 시스템 콜                | ISO C 표준 라이브러리              |
| **주요 함수** | `open`, `read`, `write` 등 | `fopen`, `fgetc`, `fread` 등 |
| **버퍼링**   | 없음 (직접 처리)                | **내부 버퍼 자동 관리**             |
| **추상화**   | 저수준                       | **고수준**                     |
| **타입**    | `int`                     | `FILE *` 구조체 포인터            |
## 스트림 지향 (Stream Orientation)
스트림은 생성 시 **무지향(unoriented)** 상태이며, 첫 입출력 함수 호출 시 지향이 결정됩니다.
- **바이트 함수** (`fgetc`, `fputs`): **byte-oriented**로 결정됩니다.
- **와이드 문자 함수** (`fgetwc`, `fputws`): **wide-oriented**로 결정됩니다.
- 지향은 한 번 결정되면 **변경 불가**합니다.
- `fwide(FILE *fp, int mode)`: 스트림의 지향을 설정하거나 확인하는 함수입니다.
## 표준 입력, 출력, 에러
프로그램 시작 시 자동으로 열리는 3개의 스트림입니다.

| 이름    | 매크로    | 용도           | 버퍼링 정책 (터미널 기준) |
| :---- | :----- | :----------- | :-------------- |
| 표준 입력 | stdin  | 사용자 입력 (키보드) | Line-buffered   |
| 표준 출력 | stdout | 일반 출력 (터미널)  | Line-buffered   |
| 표준 에러 | stderr | 오류 메시지 (터미널) | Unbuffered      |
# 2. 버퍼링 전략 (Buffering Strategies)
## 표준 I/O 버퍼링 유형
표준 I/O는 데이터를 시스템 콜 없이 일정량 모아서 처리하며, 세 가지 유형으로 제공됩니다.

| **유형**             | **설명**                | **예시 대상**                       |
| ------------------ | --------------------- | ------------------------------- |
| **Fully buffered** | 버퍼가 가득 찰 때까지 지연       | 일반 파일 (`stdin`/`stdout`이 파일일 때) |
| **Line buffered**  | **개행 문자가 나올 때** flush | 터미널 (`stdin`/`stdout`이 터미널일 때)  |
| **Unbuffered**     | **즉시** 시스템 콜로 전달      | `stderr`                        |
## 버퍼 제어 함수
- `void setbuf(FILE *fp, char *buf)`: 버퍼 On/Off 기능을 제공합니다. `buf`에 메모리 할당 포인터를 주면 On, `NULL`을 주면 Off 됩니다.
- `int setvbuf(FILE *fp, char *buf, int mode, size_t size)`: 버퍼링 모드와 크기를 세밀하게 제어합니다.
    - `mode`는 `_IOFBF` (Full), `_IOLBF` (Line), `_IONBF` (No) 중 하나입니다.
- **호출 시점**: 반드시 `fopen()` 후, **첫 입출력 전에** 호출해야 합니다.
## 버퍼 비우기 (`fflush()`)
- `int fflush(FILE *fp)`: 출력 스트림의 버퍼를 **즉시 디스크로 비웁니다 (flush)**.
    - `stderr`는 기본적으로 unbuffered이므로 `fflush()`는 효과가 없습니다.
# 3. 스트림 열기 및 닫기
## 스트림 열기 함수
- `FILE *fopen(const char *path, const char *mode)`: 경로와 모드로 새로운 스트림을 생성합니다.
- `FILE *freopen(const char *path, const char *mode, FILE *stream)`: **기존 스트림을 닫고** 새 파일과 **재연결(리디렉션)**합니다.
- `FILE *fdopen(int fd, const char *mode)`: **기존 파일 디스크립터(fd)**를 `FILE *`로 감싸서 스트림으로 사용합니다 (파이프, 소켓 등에 유용).
## `fopen` 모드
모드 문자열은 저수준 `open(2)` 시스템 콜의 플래그와 연결됩니다.
- `r` (읽기), `w` (쓰기, **기존 내용 제거**), `a` (이어쓰기).
- `+` 접미사: 읽기/쓰기 **겸용**을 의미합니다 (`r+`, `w+`, `a+`).
## 스트림 닫기
- `int fclose(FILE *fp)`: 스트림을 닫고, 출력 스트림일 경우 **버퍼를 flush한 후** 할당된 버퍼와 리소스를 반환합니다
# 4. 입출력 유형 (I/O Types)
## 문자 단위 I/O
- **입력**: `getc()`, `fgetc()`, `getchar()` (getc(stdin)과 동일).
    - 반환 값이 `int`인 이유는 문자(0~255)와 EOF(-1)를 구분하기 위함입니다.
    - `ungetc(c, fp)`: 문자 `c`를 스트림에 **되돌려 넣어** 다음 입력 시 다시 읽히도록 합니다.
    - `ferror(fp)`, `feof(fp)`: `EOF`와 오류 발생을 구별하고 상태를 확인합니다.
- **출력**: `putc()`, `fputc()`, `putchar()` (putc(c, stdout)과 동일).
## 줄 단위 I/O
- **입력**: `char *fgets(char *buf, int n, FILE *fp)`: 최대 $n-1$ 문자까지 읽고 **개행 문자를 포함하며**, 끝에 `null`을 추가하여 **문자열 안전**을 보장합니다.
    - `gets()`는 버퍼 크기 검사를 하지 않아 **보안상 취약**하며 ISO C 2011부터 제거되었습니다.
- **출력**: `int fputs(const char *str, FILE *fp)`: `null`로 끝나는 문자열을 출력하나, **개행 문자를 자동으로 출력하지 않습니다**.
    - `int puts(const char *str)`: 표준 출력에 문자열을 출력하며, **문자열 끝에 자동으로 개행 문자(`\n`)가 추가됩니다**.
- **성능**: `fgets`/`fputs`는 내부적으로 `memccpy()` 등 빠른 함수로 구현되어, 문자 단위 I/O (`getc`/`putc`)보다 **훨씬 효율적**입니다.
## 이진 (Binary) I/O
구조체 전체를 그대로 읽고 쓸 때 사용하며, 텍스트 I/O보다 빠르고 공간 효율적입니다.
- `size_t fread(void *ptr, size_t size, size_t nobj, FILE *fp)`: 바이너리 파일에서 지정된 크기(`size`)만큼 객체(`nobj`)를 읽습니다.
- `size_t fwrite(const void *ptr, size_t size, size_t nobj, FILE *fp)`: 데이터를 바이너리 형식으로 파일에 씁니다.
- **위치 지정**: `fseek()`/`ftell()`는 스트림의 위치를 `long` 또는 `off_t` (`fseeko`/`ftello`) 단위로 이동/반환합니다. `rewind()`는 스트림을 처음으로 되돌립니다.
## 형식화 (Formatted) I/O
C언어의 서식 지정(format string)을 이용해 다양한 타입의 데이터를 처리합니다.
- **출력**:
    - `printf()`: 표준 출력(`stdout`)에 출력.
    - `fprintf()`: 지정된 스트림에 출력.
    - `sprintf()`: 문자열 버퍼에 저장 (버퍼 오버플로우 위험 존재).
    - **안전한 버전**: `snprintf(buf, n, ...)`: 최대 $n-1$까지 문자를 **안전하게 저장**하여 버퍼 오버플로우를 방지합니다.
    - **저수준 연동**: `dprintf(fd, ...)`: 파일 디스크립터(fd)에 직접 포맷된 문자열을 출력합니다.
    - **가변 인자**: `vprintf`, `vfprintf` 등은 `va_list`를 인수로 받아 가변 인자 목록을 다른 함수에 전달할 때 유용합니다.
- **입력**: `scanf()`, `fscanf()`, `sscanf()`: 각각 표준 입력, 스트림, 문자열 버퍼로부터 포맷에 따라 값을 입력/추출합니다.
## `fileno()`
- `int fileno(FILE *fp)`: 특정 스트림(`FILE *`)에 연관된 파일 디스크립터(`int`)를 리턴합니다. 저수준 I/O 함수 (`dup()`, `fcntl()`)를 호출할 때 필요합니다.
# 5. 임시 파일 (Temporary File)
임시 파일은 임시 작업, 로그 등에 안전하게 사용됩니다.

| **함수**                          | **기능**                           | **특징**                                                                    |
| ------------------------------- | -------------------------------- | ------------------------------------------------------------------------- |
| `char *tmpnam(char *ptr)`       | 유효하고 고유한 **임시 파일 이름** 생성         | 재호출 시 이름이 덮어쓰기 될 수 있음                                                     |
| `FILE *tmpfile(void)`           | 임시 파일 생성 및 `FILE *`로 열기          | 파일 닫히거나 프로세스 종료 시 **자동으로 삭제됨**                                            |
| `char *mkdtemp(char *template)` | 고유 이름을 가진 임시 **디렉터리** 생성 및 오픈    | `template`의 `XXXXXX`를 고유 이름으로 대체.                                         |
| `int mkstemp(char *template)`   | 고유 이름을 가진 임시 **파일** 생성 및 `fd` 반환 | `XXXXXX`를 고유 이름으로 대체. **직접 `unlink()`로 삭제해야 함**. 보안상 안전하며 경쟁 상태 문제가 없습니다. |
**주의**: `mkstemp`는 `char template[] = "..."` 와 같이 **수정 가능한 버퍼**를 사용해야 합니다. `char *template = "..."` (읽기 전용 문자열 리터럴)을 사용하면 `Segmentation fault`가 발생합니다.