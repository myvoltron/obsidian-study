# 1. 프로세스 기본 (Process Basics)
## 프로세스 식별자 (Process Identifier)
프로세스를 식별하는 고유한 정수 ID(양수)입니다.
- **PID (`pid_t`)**: 현재 프로세스의 고유 ID입니다. PID 0은 스케줄러, PID 1은 `init` 또는 `launchd`입니다.
- **PPID**: 부모 프로세스의 ID입니다.
- **실제/실효 사용자 및 그룹 ID**:
    - **RUID/RGID** (`getuid`/`getgid`): 사용자의 실제 ID (로그인 시 설정).
    - **EUID/EGID** (`geteuid`/`getegid`): 파일 접근 권한 판별 시 사용되는 **실효 ID**.
# 2. 프로세스 생성 및 종료
## `fork()`
**부모 프로세스를 복사**하여 자식 프로세스를 생성하는 핵심 시스템 호출입니다.
- **하나의 호출, 두 번의 반환**:
    - **자식**: `0` 반환.
    - **부모**: 새로 생성된 **자식 프로세스의 PID** 반환.
- **메모리 공유**: 자식은 부모의 독립적인 복사본(스택, 힙 등)을 가지며, 비용 절감을 위해 **Copy-On-Write (COW)** 기술이 사용됩니다.
- **파일 디스크립터 공유**: 부모와 자식은 열려 있는 파일 디스크립터를 `dup()` 호출처럼 **공유**합니다. 즉, **파일 테이블, 오프셋, v-node 정보 모두를 공유**하여, 둘 중 하나가 `write()`를 호출하면 같은 위치에 기록됩니다.
	- 따라서 동시에 출력 시 결과가 섞일 수 있음
	- -> **동기화 필요**: `wait()`, `close()`로 분리, 혹은 IPC로 동기화
- **공유되지 않는 속성**: PID, PPID, fork 반환 값 등 
- **일반적 용도**: 프로세스 복제 후 역할 분리 (예: 서버), 다른 프로그램 실행을 위한 준비 단계 (`exec` 이전).
## `vfork()`
`fork()` 후 **곧바로 `exec()`를 호출**할 경우 메모리 복사 낭비를 막기 위해 탄생했습니다. (바로 `exec` 할거면 복사한 메모리 쓸모없음)
- **동작 방식**: 부모와 자식이 **주소 공간을 공유**한 채로 시작합니다.
- **제한 사항**: **자식이 `exec()` 또는 `_exit()`를 호출하기 전까지 부모는 멈춥니다**. 자식이 변수를 바꾸면 부모에 영향을 미치므로, 변수 변경은 피해야 합니다.
- **종료 시점**: 자식은 `exit()` 대신 `_exit(0)`을 호출해야 합니다. `exit(0)`은 표준 I/O 버퍼를 플러시하려고 시도하는데, 이는 부모와 공유된 자원이므로 예측 불가능한 결과를 초래할 수 있습니다.
## 프로세스 종료 및 상태
### 종료 상태 vs 종지 상태

| 개념                             | 설명                                                    | 예시                                   |
| ------------------------------ | ----------------------------------------------------- | ------------------------------------ |
| **종료 상태 (Exit Status)**        | `exit()`, `return`, `_exit()` 등에서 **프로세스가 커널에 넘기는 값** | `exit(3);`에서 3이 **exit status**      |
| **종지 상태 (Termination Status)** | 커널이 내부적으로 정리해 **부모에게 전달하는 상태 정보**                     | `wait()` 호출 시 상태 코드로 `*statloc`에 전달됨 |
### 부모가 먼저 종료된 경우(고아 프로세스)
- 커널이 자동으로 init 프로세스 (PID 1)에게 부모를 위임
- init은 자식이 종료되면 `wait()` 호출로 수거해 좀비 상태 없이 종료 처리
### 자식이 먼저 종료된 경우(좀비 프로세스)
- 자식이 먼저 종료되어도 부모가 `wait()` 호출하기 전까지 커널에 정보가 남아있음 ex) PID, 종료 상태, 사용 시간 등
- 부모가 아직 `wait()` 호출 X -> 좀비 프로세스 발생
	- 오직 부모만이 자식의 PCB 정리를 명령할 수 있음
- 누적되면 시스템 자원 고갈 -> 반드시 `wait()` 필요
# 3. 프로세스 대기 및 동기화
- 자식 프로세스가 종료되면 부모에게 통지를 함: `SIGCHLD`
- 부모는 **signal handler** 등록을 할 수 있고 이 때 기본값은 무시됨
- 또는 `wait()`, `waitpid()`를 통해 종지 상태 회수 가능
	- 이 때 부모는 다음 상태일 수 있음:
		- **자식이 종료 전**: **block** (자식이 업무 끝날 때까지 대기)
		- 자식이 **좀비 상태**: 즉시 반환
		- 자식이 **없음**: 에러 반환
## `wait()`와 `waitpid()`
자식 프로세스의 종료를 기다리고 종지 상태를 회수하는 함수입니다.
- `pid_t wait(int *statloc)`: **임의의** 종료된 자식 프로세스를 기다립니다 (블로킹).
- `pid_t waitpid(pid_t pid, int *statloc, int options)`: **특정** 자식(`pid > 0`)의 종료를 기다리며, `options`로 **블로킹 여부 (`WNOHANG`)** 및 기타 상태 감지를 제어할 수 있습니다.
	- **`pid` 인수의 용법**:
	    - `-1`: 아무 자식 프로세스나 기다림 (`wait()`와 동일).
	    - `> 0`: 지정된 PID의 자식 프로세스만 기다림.
	    - `0`: 같은 프로세스 그룹 ID를 가진 자식 중 하나가 종료될 때까지 기다림.
    - `Options` 인수
	    - `WNOHANG`: 자식 프로세스가 종료되지 않았다면 블로킹하지 않고 즉시 0 반환
	    - `WUNTRACED`: 정지된 자식 프로세스의 상태도 반환 -> `WIFSTOPPED(status)`로 확인
	    - `WCONTINUED`: 정지 후 다시 실행된 자식의 상태도 반환 -> `WIFCONTINUED(status)`로 확인
## 종지 상태 조사 매크로
`wait`/`waitpid`가 `*statloc`에 저장한 종지 상태를 분석하는 매크로입니다:
- `WIFEXITED(status)`: 자식이 **정상 종료**되었는지 확인. $\to$ `WEXITSTATUS(status)`로 exit에서 전달한 값 확인.
- `WIFSIGNALED(status)`: 자식이 핸들링 못한 **시그널로 비정상 종료**되었는지 확인. $\to$ `WTERMSIG(status)`로 시그널 번호 확인.
- `WIFSTOPPED(status)`: 자식이 현재 **정지(stopped) 상태**인지 확인. -> `WSTOPSIG(status)로 정지 원인 시그널 확인`
- `WIFCONTINUED(status)`: 자식이 정지 후 **다시 실행 상태로 전환**되었으면 true (`waitpid`에서만 사용 가능)
## Race Condition
- 다수의 프로세스가 공유 자원에 접근할 떄 실행 순서에 따라 결과가 달라지는 상황
- `fork()` 이후 부모자식 중 누가 먼저 실행될지 예측 불가
- **해결 방법**: 
	- 대화로 해결: `signal`, `pipe` 등을 이용한 **동기화 함수**를 이용해 프로세스간 순서 명확히 지정 가능
	- 주기적으로 작업중인지 확인하기 (폴링)
# 4. 프로그램 실행 및 ID 관리
## `exec()` 계열
**현재 프로세스를 새 프로그램으로 대체**하는 함수들입니다.
- **특징**: **프로세스 ID (PID)는 그대로 유지**되며, 메모리 영역(텍스트, 데이터, 힙, 스택)은 전부 교체됩니다.
- **성공 시 반환 없음**: 새 프로그램이 `main()`부터 실행을 시작하며, 성공 시 제어권을 상실하므로 원래 코드로 돌아오지 않습니다. 실패 시에만 `-1`을 반환합니다.
- **시스템 콜**: `execve()`가 exec 계열 중 **유일한 시스템 콜**이며, 나머지는 `execve()`를 호출하는 래퍼(wrapper) 함수입니다.
- **핵심 조합**: **`fork() + exec() + wait() + exit()`**는 프로세스 제어의 가장 중요한 조합입니다.

| **함수 이름** | **경로 지정**          | **인자 전달**        | **환경 변수**                 |
| --------- | ------------------ | ---------------- | ------------------------- |
| `execl`   | Pathname           | List             | Inherited                 |
| `execv`   | Pathname           | Array (`argv[]`) | Inherited                 |
| `execle`  | Pathname           | List             | Explicit Array (`envp[]`) |
| `execve`  | Pathname           | Array            | Explicit Array            |
| `execlp`  | Filename (PATH 검색) | List             | Inherited                 |
| `execvp`  | Filename (PATH 검색) | Array            | Inherited                 |
| `fexecve` | FD                 | Array            | Explicit Array            |
- **`p` 접미사**: 실행할 파일을 **`PATH` 환경 변수**에서 검색합니다. -> **filename** 사용
	- `/` 포함: 경로로 처리
	- `/` 없음: PATH 환경변수로 탐색
- **`fexecve`**: **열린 파일 디스크립터(FD)**로 직접 실행하며, 경로 탐색이 필요 없어 **TOCTTOU 공격을 방지**합니다.
## `exec()` 이후 유지되는 속성
- **유지**: PID, PPID, Real UID/GID, **Controlling terminal**, 현재 작업 디렉터리, `umask`, **열려있는 파일 디스크립터들**, **pending signals**
    - **예외**: `FD_CLOEXEC` 플래그가 설정된 FD는 닫힙니다.
- **유지 안 됨 (새로 로드됨)**: 프로그램 코드, 데이터 영역, 힙, 스택, 전역/지역 변수, 등록된 시그널 핸들러.
## 사용자 ID 변경
- **`setuid(uid)`** 및 **`setgid(gid)`**: 프로세스의 UID/GID를 변경합니다.
    - **Superuser**: RUID, EUID, Saved-UID **모두** 변경 가능.
    - **일반 사용자**: EUID만 변경 가능하며, 자신의 RUID/EUID/SUID 중 하나로만 변경할 수 있습니다.
- **`seteuid(uid)`**: **Effective UID만 변경**하며, 일반 사용자는 자신의 Real UID 또는 Saved UID로만 변경할 수 있어, **임시 권한 상승 후 복구**하는 보안 목적에 적합합니다.
# 5. 고급 주제
## 인터프리터 파일
`#! pathname [optional-arg]`로 시작하는 텍스트 파일입니다.
- **동작**: `exec` 시 커널이 직접 해석하며, 실제 실행 파일은 첫 줄의 `pathname`입니다.
- **장점**: 스크립트 언어임을 숨기고, 불필요한 셸 중첩을 회피하여 효율적으로 실행합니다.
## `system()` 함수
명령 문자열을 **셸을 통해 실행**하는 함수입니다.
- **내부 동작**: `fork` $\to$ `exec("/bin/sh -c cmd")` $\to$ `wait`를 수행합니다.
- **반환값**: `fork`/`waitpid` 실패 시 -1, `exec` 실패 시 127, **성공 시 자식 종료 상태를 반환**.
- **주의 사항**: **set-user-ID 프로그램에서 `system()` 호출은 보안 위험이 매우 큽니다** (악의적 명령 삽입 시 권한 상승 가능).
## 프로세스 회계 (Process Accounting)
각 프로세스 종료 시 커널이 UID, GID, CPU 시간, I/O 사용량 등을 기록하는 기능입니다.
- **파일**: `/var/account/acct`, `/var/log/account/pacct` 등.
- **한계**: 비표준이며, 종료하지 않는 프로세스(예: `init`)는 기록되지 않습니다.
## 프로세스 스케줄링 (`nice`)
- **`nice` 값**: 프로세스의 스케줄링 **우선순위를 조절**하는 값입니다. 값이 높을수록 우선순위는 낮아집니다 ("더 양보").
- **권한**: 일반 프로세스는 우선순위 **낮추기만 가능**하며, 올리려면 특권 사용자(root)가 필요합니다.
- **함수**: `int nice(int incr)`로 현재 값에 `incr`를 더해 변경합니다. `getpriority`/`setpriority`로 프로세스/그룹/사용자 단위로 설정 가능합니다.
## 프로세스 시간 (`times`)
- **Wall clock time**: 실제 경과 시간.
- **User CPU time**: 사용자 코드에서 소비한 시간.
- **System CPU time**: 커널 코드에서 소비한 시간.
- `clock_t times(struct tms *buf)`: 현재 Epoch 기준 시각(Wall clock time)을 반환하고, `tms` 구조체에 CPU 시간들을 저장합니다.