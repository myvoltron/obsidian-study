# 1. 파일 크기 `st_size`
- `stat()` 구조체의 `st_size` 필드에 저장됨. (바이트 단위)
- 파일 내용의 실제 길이를 의미. 디스크 상에서 차지하는 블록 수가 아님.
## 희소 파일(Sparse file)
- 데이터가 없는 부분은 디스크 블록 없이 비어 있음
- `st_size`는 커도, 실제 할당된 블록 수는 적음
## Truncation
- `int truncate(const char *pathname, off_t length)`
	- 지정한 경로의 파일을 length 바이트로 **절단**
	- 기존보다 **짧게** -> 데이터 손실
	-       "      **길게** -> 뒤쪽에 null 바이트로 패딩
- `int ftruncate(int fd, off_t length)`
	- **파일 쓰기 권한**이 있어야 호출 가능
# 2. 파일 시스템
- 디스크에 파일과 디렉터리를 저장하고 조직하는 구조
- 파일 시스템은 파일의 데이터, 메타데이터, 디렉터리 계층 관리
- UNIX 시스템에서는 여러 파일 시스템이 하나의 디렉터리 트리에 마운트됨
- **파일 시스템 구조**: 디스크는 파티션으로 나뉘고, 각 파티션은 부트 블록, 슈퍼 블록, 실린더 그룹 등으로 구성됩니다.
- **I-node**: 파일의 메타데이터(크기, 권한, 디스크 블록 주소 등)를 저장하는 구조체입니다. **파일 이름은 i-node에 저장되지 않습니다.**
- **디렉터리**: **파일 이름**과 해당 파일의 **i-node 번호**를 매핑하여 저장하는 특수한 파일입니다.
![[Pasted image 20251018235157.png|500]]
![[Pasted image 20251018235233.png|500]]
![[Pasted image 20251018235309.png|500]]
# 3. 링크 및 파일 시스템 구조
## Hard Link vs Symbolic Link (Soft Link)

| **항목**        | **Hard Link**                 | **Symbolic Link**                |     |
| ------------- | ----------------------------- | -------------------------------- | --- |
| **i-node 공유** | O (같은 i-node 번호 공유)           | X (별도 i-node 가짐)                 |     |
| **내용 저장**     | 동일한 데이터 영역                    | **링크 경로 문자열**                    |     |
| **제약**        | 같은 파일 시스템 내에서만 가능, 디렉터리 생성 불가 | 다른 파일 시스템 가능, 디렉터리 가능            |     |
| **대상 삭제 시**   | 여전히 접근 가능 (링크 카운트가 0이 될 때까지)  | **깨짐** (**Dangling symlink** 가능) |     |
### Symbolic link
- 경로를 참조하는 함수는 **보통 링크를 따라감**
- `lstat()`, `unlink()` 등은 **링크 자체를 대상**으로 동작
- **심볼릭 링크로 인한 루프** 및 오류 가능
	- 디렉터리 구조에 루프 생성 가능: `foo/testdir -> ../foo`
	- 대부분 시스템 호출은 루프 감지 시 `ELOOP` 반환
## 링크 생성
- `link(existingpath, newpath)`: 
	- 기존 파일에 대해 **새로운 하드 링크** 생성 -> 링크 카운트 증가
	- 기존과 같은 **i-node 공유**
	- 경로가 심볼릭 링크여도 **타겟을 따라감**
- `linkat(olddirfd, oldpath, newdirfd, newpath, flags)`:
	- `flags`에 `AT_SYMLINK_FOLLOW` 지정 시 심볼릭 링크 타켓 따라감
- `symlink(target, linkpath)`: 심볼릭 링크 생성 (대상 경로가 존재하지 않아도 생성 가능).
- `symlinkat(target, newdirfd, linkpath)`
- `readlink(pathname, buf, bufsiz)`: 심볼릭 링크가 가리키는 **경로 문자열**(링크 자체의 내용)을 읽습니다.
- `readlinkat(dirfd, pathname, buf, bufsiz)`
## 링크(이름) 제거
- `unlink(pathname)`: 
	- 디렉터리에서 **이름을 제거** 
	- i-node의 **링크 카운트를 감소**시킵니다. 링크 카운트가 0이고 열린 프로세스가 없을 때 -> 파일이 실제로 제거됨
	- `rm` 명령어가 내부적으로 사용
- `unlinkat(dirfd, pathname, flags)`:
	- `flags`에 `AT_REMOVEDIR` 지정 시 **디렉터리 제거** 시도
- `remove(pathname)`: 일반 파일이면 `unlink()`를, 디렉터리이면 `rmdir()`을 호출합니다.
## 이름 관리
- `rename(oldpath, newpath)`: 
	- 파일 또는 디렉터리의 이름을 변경 -> `mv`가 내부적으로 사용
	- `newpath`가 존재하면 **원자적 연산으로 덮어씁니다**. 
	- 디렉터리 이동 시, **대상은 비어**있어야함.
	- 크로스 파일 시스템 간 이동 불가능 (`EXDEV`)
- `renameat(olddirfd, oldpath, newdirfd, newpath)`
- 파일(or 심볼릭 링크) 이름 변경 시
	- 새 이름이 **디렉터리** -> 에러
	- 새 이름이 **존재하는 일반 파일** -> 기존 파일 **삭제 후 교체**
- 디렉터리 이름 변경 시
	- 새 이름이 **비어있는 디렉터리여야만 가능**
	- 새 이름이 **oldname** 하위 경로면 안됨
- **oldname**, **newname** 둘 중 하나가 링크라면, 링크 자체를 이름 변경 대상으로 처리
# 4. 시간 정보
## 파일 시간 (File Times)
`stat` 구조체에는 다음과 같은 시간 정보가 저장됩니다:
- **Access time (`atime`)**: 마지막으로 파일을 읽은 시간.
- **Modification time (`mtime`)**: 마지막으로 파일 **내용**을 수정한 시간.
- **Change time (`ctime`)**: i-node 정보(소유자, 권한 등)가 변경된 시간.
- **Birth time (`btime`)**: Linux `statx()` 시스템 콜에서 제공되는 **파일 생성 시간** (최신 정보).
## `timeval` vs `timespec`
- `timeval`: sec + usec($10^{-6}$) <- 마이크로초...
- `timespec`: sec + nsec($10^{-9}$) <- **나노초**, 최신 POSIC 표준에서 **더 선호됨**
## 파일 시간 정보 변경
- `futimens(int fd, const struct timespec times[2])`
- `utimensat(int dirfd, const char *pathname, const struct timespec times[2], int flags)`
	- `flags == AT_SYMLINK_NOFOLLOW` -> 심볼릭 링크 자체 시간 변경
- `utimes(const char *pathname, const struct timeval times[2])`
	- 마이크로초 단위 시간 설정
- **시간 변경**: `futimens()` 또는 `utimensat()`로 `atime`과 `mtime`을 수정할 수 있으나, `ctime`은 **커널이 자동으로 관리**하며 사용자가 직접 설정할 수 없습니다.
	- `times == NULL` -> 현재 시각으로 설정
	- `tv_nsec == UTIME_NOW` -> 현재 시각으로 설정 (`tv_sec` 무시)
		- 쓰기 권한 or 소유자 or root
	- `tv_nsec == UTIME_OMIT` -> 변경 안함
		- 권한 검사 X
	- 직접 값 지정 -> `tv_sec`, `tv_nsec` 지정 
		- 소유자 or root
# 디렉터리 I/O
## 디렉터리 생성 및 제거
- `mkdir(pathname, mode)`: 새 디렉터리 생성
	- `mode`: 새 디렉터리의 권한 (**umask**의 영향 있음)
- `mkdirat(dirfd, pathname, mode)`
- `rmdir(pathname)`: **비어있는 디렉터리만** 삭제 가능
## 디렉터리 순회
디렉터리는 일반 파일과 달리 전용 함수를 통해 접근합니다.
- `opendir(pathname)`: 디렉터리를 열고 `DIR*` 구조체를 반환합니다.
- `readdir(DIR *dp)`: 다음 디렉터리 엔트리를 읽어 `struct dirent*`를 반환합니다.
- `closedir(DIR *dp)`: 디렉터리 스트림을 닫습니다.
- **디렉터리 순회**: `opendir()` -> `while(readdir())` -> `closedir()` 패턴을 사용하여 디렉터리 내용을 읽습니다.
## 작업 디렉터리 변경
- `chdir(pathname)`: 현재 작업 디렉터리(Current Working Directory, CWD)를 변경합니다.
- `getcwd(buf, size)`: 현재 작업 디렉터리의 **절대 경로**를 반환합니다.
    - `cd` 명령은 셸의 내장 명령어이며, 자식 프로세스가 `chdir()`을 호출해도 부모 셸의 CWD에는 영향을 미치지 않습니다.