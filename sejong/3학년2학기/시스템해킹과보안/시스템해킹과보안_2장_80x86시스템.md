# 1. 80x86 CPU 구조
- ALU(Arithmetic and Logic Unit): CPU의 핵심. **산술 연산**과 **논리 연산**을 수행하는 회로 집합으로 이루어짐.
- Control Unit: I/O, memory, ALU 등을 제어하고 memory에 저장된 **명령을 해독**하여 연산 장치로 보내 처리하게 함.
## 1.1 CPU 레지스터 종류 및 용도
> [!note]
> **GSP IE** -> General, Stack, Pointer, Index, EFALGS

| 범주      | 80386 레지스터 | 이름            | 비트  | 용도                             |
| ------- | ---------- | ------------- | --- | ------------------------------ |
| General | EAX        | 누산기 레지스터      | 32  | 산술 연산 결과 저장, 함수 반환 값           |
| General | EBX        | 베이스 레지스터      | 32  | 데이터 포인터, 베이스 주소 지정             |
| General | ECX        | 카운터 레지스터      | 32  | 루프 및 문자열 연산 카운터                |
| General | EDX        | 데이터 레지스터      | 32  | 큰 산술 연산의 상위 비트, I/O 포인터        |
| Segment | CS         | 코드 세그먼트 레지스터  | 16  | 현재 실행 중인 코드 세그먼트의 시작 주소        |
| Segment | SS         | 스택 세그먼트 레지스터  | 16  | 현재 스택 세그먼트의 시작 주소              |
| Segment | DS         | 데이터 세그먼트 레지스터 | 16  | 기본 데이터 세그먼트의 시작 주소             |
| Segment | ES         | 추가 세그먼트 레지스터  | 16  | 추가 데이터 세그먼트의 시작 주소 (주로 문자열 연산) |
| Segment | FS         | 추가 세그먼트 레지스터  | 16  | 추가 데이터 세그먼트의 시작 주소             |
| Segment | GS         | 추가 세그먼트 레지스터  | 16  | 추가 데이터 세그먼트의 시작 주소             |
| Pointer | ESP        | 스택 포인터 레지스터   | 32  | 스택의 최상단을 가리킴                   |
| Pointer | EBP        | 베이스 포인터 레지스터  | 32  | 스택 프레임의 베이스를 가리킴               |
| Index   | ESI        | 소스 인덱스 레지스터   | 32  | 문자열 및 메모리 복사 연산의 소스 포인터        |
| Index   | EDI        | 목적지 인덱스 레지스터  | 32  | 문자열 및 메모리 복사 연산의 목적지 포인터       |
| Flags   | EFLAGS     | 플래그 레지스터      | 32  | CPU 상태, 제어 및 결과 플래그 저장         |
- Status Flag: 산술 연산의 결과를 반영하는 Flag
	- CF(Carry Flag, 0 bit): 산술 연산 후 자리 올림/내림 발생 시
	- OF(Overflow Flag, 11 bit): 부호 있는 수에서 overflow 혹은 MSB 변경 시
	- ZF(Zero Flag, 6 bit): 결과가 0일 시
- Control Flag
	- DF(Direction Flag): if DF is 1, 스트링 명령 자동 감소 otherwise.
- System Flag: 운영체제나 장치 드라이버 제어
# 2. 메모리 구조
![[Pasted image 20251015123508.png|400]]
- 스택: LIFO 구조로 스택의 끝 부분에서 데이터를 삽입하거나 제거한다. 보통 함수를 호출할 경우 함수 로컬 변수를 저장한다. 
- 힙: 프로그램이 실행 중 필요한 메모리를 **운영체제가 동적으로 할당하고 해제하는 영역**으로, 포인터를 통해 접근한다. 필요하지 않은 메모리는 반환하여 다시 사용 가능하며, **연결 리스트, 트리, 그래프**처럼 크기가 가변적인 자료구조에서 주로 사용된다.
- BSS 세그먼트(초기화 되지 않은 데이터 세그먼트): 프로그램을 실행할 때 0이나 NULL로 초기화됨. 초기화 되지 않은 **전역 변수**나 **static 변수** 등을 저장.
- 데이터 세그먼트(초기화 된 데이터 세그먼트): 초기화된 전역 변수나 static 변수 등을 저장.
- 텍스트 세그먼트(코드 세그먼트): **CPU**가 실행할 **기계어** 코드 저장.
## 2.1 메모리 접근 모드
### 2.1.1 Real Mode
- 8086 CPU에서 사용하던 모드
- 16비트 offset + 16bit 세그먼트 레지스터 = 20 bit 주소 공간 -> 1MB 메모리 사용 가능
### 2.1.2 Protected Mode
- 32 bit 80386 CPU에서 완성된 모드
- 32 bit 주소 공간 -> 4GB 메모리 사용 가능
- Segmentation과 Paging을 이용해 메모리를 관리한다.
## 2.2 세그먼트 레지스터별 기본 오프셋 레지스터

| 세그먼트 레지스터  | 오프셋 레지스터   |
| ---------- | ---------- |
| CS         | IP         |
| DS         | SI, DI, BX |
| SS         | BP, SP     |
| ES(FS, GS) | SI, DI, BX |
# 3. 어셈블리어 구조
## 3.1 데이터 타입
- byte: 1바이트(8비트)
- word: 2바이트
- double word: 4바이트
## 3.2 리틀 엔디안
- 가장 낮은 주소에 하위 바이트(LSB)**, **가장 높은 주소에 상위 바이트(MSB)** 를 저장하는 방식이다. 
- ex) 값 0x34F3를 주소 1500에 저장하면 1500에는 0xF3, 1501에는 0x34가 저장된다.
## 3.3 주소 지정 방식
### 3.3.1 Register Addressing
- 레지스터의 주소 값 복사
- the fastest
- `MOV DX, BX`
### 3.3.2 Direct Addressing
- 가장 일반적인 방식. 
- 보통 피연산자 하나는 메모리 다른 하나는 레지스터 참조
- `MOV AL, DS:[8080h]`
### 3.3.3 Register Indirect Addressing
- `세그먼트:오프셋` 형식 사용
- `MOV AL, [BX]`
### 3.3.4 Indexed Addressing
- Register Indirect Addressing + Displacement
- `MOV AL, [BX + 20h]`
### 3.3.5 Base Index Addressing
- 베이스 레지스터(BX, BP)와 인덱스 레지스터(SI, DI) 결합
- `MOV AL, [BX + SI]`
### 3.3.6 Base Indexed + Displacement Addressing
- Base Index Addressing + Displacement
- `MOV AL, [BX + SI + 20h]`
## 3.4 기본 명령
### 3.4.1 Arithmetic Instruction
- 메모리나 범용 레지스터에 위치한 값에서 계산.
- ADD, SUB, MUL, DIV, CMP
### 3.4.1 Data Transfer Instruction
- 메모리, 범용 레지스터, 세그먼트 레지스터로 참조되는 주소로 데이터 전송
- MOV, LEA, PUSH, POP, XCHG, IN, OUT
### 3.4.1 Logical Instruction
- AND, OR, XOR, NOT, TEST
### 3.4.1 String Manipulation Instruction
- 바이트로 구성된 데이터를 메모리로 전송하거나 가져옴.
- REP, MOVS
### 3.4.1 Control Transfer Instruction
- 점프, 조건 점프, 루프, 호출, 리턴 등으로 프로그램의 흐름 제어.
- JMP, LOOP, CALL ,RET, INT
### 3.4.1 Processor Control Instruction
- Flag 레지스터를 세트하거나 클리어.
- STC, NOP
# 4. 실습
## 4.1 프롤로그/prelude
```nasm
pushl %ebp
movl %esp, %ebp
```
- 새로운 **함수 시작** 시 stack frame을 설정하는 코드
- 이전 함수의 frame을 저장 후 새로운 frame을 만듬
- 이 때, 스택에 저장된 ebp를 **sfp**(stack frame pointer)라고 부름.
- 함수 호출 전 인자는 **역순**으로 스택에 push됨.
## 4.2 에필로그
```nasm
leave
ret
```
- **함수 종료** 시 항상 호출되는 코드
## 4.3 용량 할당 
```nasm
sub $4, %esp
```
- esp 값에서 필요한 용량만큼 뺀다. (4 바이트 단위로)
## 4.4 shellcode 분석
- 주소 찾기 알고리즘: 공격 시 조작된 ret -> Jump(to Call) -> Call(Shell)

1. NULL로 끝나는 "/bin/sh" 문자열을 임의의 메모리에 배치함
2. /bin/sh 문자열의 주소를 임의의 메모리에 배치함
3. 0xb를 EAX 레지스터에 저장
4. /bin/sh 문자열 주소를 EBX 레지스터에 저장 (name[0]에 해당)
5. /bin/sh 주소를 저장하는 주소를 ECX 레지스터에 저장 (name에 해당)
6. 워드 길이를 가지는 null의 주소를 EDX 레지스터에 저장 (Null에 해당)
7. int $0x80 호출
추가로 exit을 위한 명령도 추가함
8. 0x1을 EAX 레지스터에 복사
9. 0x0을 EBX 레지스터에 복사
10. int $0x80 호출