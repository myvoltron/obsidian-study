Created at:  2025-08-28 01:29
Tag: #algorithm #dp  
References:
Link Notes:

# 0/1 배낭 문제 정의
- 아이템 i는 **무게 w[i]**, **가치 v[i]**.
- 가방 용량 **W**.
- 각 아이템은 **딱 한 번만** 담을 수 있음(0/1).
- **가치의 최댓값**을 구해라.
# 점화식
- `dp[i][w]` = i번째까지 고려했을 때, 용량이 w인 배낭의 최대 가치
```python
dp[i][w] = dp[i-1][w]                            # i번째 아이템을 담지 않음
dp[i][w] = max(dp[i-1][w], dp[i-1][w - wi] + vi) # (w >= wi)
```
# 시간 복잡도
- `O(N · W)`
- N은 아이템 개수, W는 배낭 용량.
- 메모리: O(N · W) (2차원) → O(W) (1차원 최적화 가능)
# 코드
```python
def knapsack_2d(weights, values, W):
    n = len(weights)
    dp = [[0] * (W + 1) for _ in range(n + 1)]
    for i in range(1, n + 1):
        w, v = weights[i-1], values[i-1]
        for cap in range(W + 1):
            dp[i][cap] = dp[i-1][cap]
            if cap >= w:
                dp[i][cap] = max(dp[i][cap], dp[i-1][cap-w] + v)
    return dp[n][W]
```

# 예시
## 예시 입력
```python
W = 10
weights = [6, 4, 3, 5]
values  = [13, 8, 6, 12]
```
- 배낭 용량: 10
- 아이템 4개:
    1. 무게 6, 가치 13
    2. 무게 4, 가치 8
    3. 무게 3, 가치 6
    4. 무게 5, 가치 12
## DP 테이블 해석
- `dp[i][cap]`: 아이템 1~i까지 고려했을 때, 용량이 cap인 배낭의 최대 가치.
## 단계별 진행
### i=1 (아이템1: w=6, v=13)
- 용량이 0~5: 담을 수 없음 → 전부 0
- 용량이 6 이상: `dp[1][cap] = max(dp[0][cap], dp[0][cap-6]+13) = 13`
```python
dp[1] = [0,0,0,0,0,0,13,13,13,13,13]
```
### **i**=2 (아이템2: w=4, v=8)
- cap=4: `max(dp[1][4]=0, dp[1][0]+8=8)` → 8
- cap=6: `max(dp[1][6]=13, dp[1][2]+8=8)` → 13
- cap=10: `max(dp[1][10]=13, dp[1][6]+8=21)` → 21
```python
dp[2] = [0,0,0,0,8,8,13,13,13,13,21]
```
### i=3 (아이템3: w=3, v=6)
- cap=3: `max(0, dp[2][0]+6=6)` → 6
- cap=7: `max(13, dp[2][4]+6=14)` → 14
- cap=10: `max(21, dp[2][7]+6=19)` → 21 (여전히 더 큼)
```python
dp[3] = [0,0,0,6,8,8,13,14,14,19,21]
```
### i=4 (아이템4: w=5, v=12)
- cap=5: `max(8, dp[3][0]+12=12)` → 12
- cap=9: `max(19, dp[3][4]+12=20)` → 20
- cap=10: `max(21, dp[3][5]+12=20)` → 21
```python
dp[4] = [0,0,0,6,8,12,13,14,18,20,21]
```
## 최종 답
`dp[4][10] = 21`
👉 최대 가치는 **21**.

이를 만드는 조합은:
- 아이템1 (무게6, 가치13) + 아이템2 (무게4, 가치8) = 총 무게 10, 가치 21
# 결론
- 2차원 DP는 `dp[i][cap]`이 “i번째 아이템까지 고려했을 때 용량 cap 최적”이라는 의미라서 **직관적**임.
- 각 단계에서 **담을지/안 담을지**만 비교하는 게 점화식의 핵심.
- 최종적으로 `dp[n][W]`가 답.