Created at:  2025-01-13 17:06
Tag: #javascript #syntax #error 
References:
Link Notes:

### 에러 처리를 해야하는 이유

에러는 무조건 항상 발생할 가능성이 있다! 그런데 이러한 에러를 그냥 방치해두면 프로그램이 강제 종료된다. 실제로 백엔드 서버를 만들 때 에러가 처리되지 않아 프로그램이 갑자기 종료되면 실제 서비스를 이용하는 유저들이 불편을 느낄테니... 굉장히 중요한 부분인거 같다.

우선 `try ... catch` 문법으로 에러에 대응하면 프로그램이 종료되는 일 없이 계속해서 실행되는 상태를 유지시킬 수 있다.

```jsx
try {
	// 실행할 코드들이 여기에 담긴다 
} catch (err) {
	// try 블록안에서 에러가 발생하면 catch가 에러를 잡아서 이 블록안의 코드가 실행된다.
} finally {
	// 에러 발생과 상관없이 무조건 한 번 실행되는 곳. 
}
```

- `try`블록에서 에러가 발생하면 `catch`의 `err`변수에 그 에러가 할당되서 그 블록안에서 활용될 것이다.
- 이러한 방식으로 에러를 처리하면 프로그램이 종료되지 않을 것이다

### Error 객체와 throw문

- Error 생성자 함수는 에러 객체를 생성한다. 생성자 함수에는 에러를 상세히 설명하는 에러 메시지를 인수로 전달할 수 있다.
- 에러 객체는 `message` 프로퍼티와 `stack` 프로퍼티를 가진다.
    - `message` : 에러 메시지
    - `stack` : 에러를 발생시킨 콜스택의 호출 정보를 담는다. (에러 전파 참고)

그런데 코드상에서 이 에러 객체를 만든다고 해서 `catch`문이 해당 에러를 바로 잡을 수 있는 것은 아니다. `catch`문이 에러를 인식하게 하려면 에러를 `throw`해줘야 한다.

- 에러 객체 생성과 **에러 발생**의 의미를 구별해서 알아두자!
- 아무튼 이 `throw`를 `try`블록안에서 써주면 `catch`가 잡을 수 있다.

```jsx
try {
	throw new Error(`something wrong`); // throw error
} catch (err) {                       // catch error!
	console.log(err); 
}
```

### 에러의 전파

<aside> 💡

에러는 호출자 방향으로 전파된다.

</aside>

그러니까... 현재 어떠한 함수를 실행하면서 에러가 발생했다면 그 함수를 호출한 곳으로 에러가 전파된다는 것이다.

```jsx
const foo = () => {
	throw Error('foo에서 발생한 에러'); // 4. 
};

const bar = () => {
	foo(); // 3. 
};

const baz = () => {
	bar(); // 2. 
};

try {
	baz(); // 1. 
} catch (err) {
	console.log(err); 
}
```

1. 에서 baz함수를 호출하면
2. 에서 bar함수가 호출되고
3. 에서 foo함수가 호출되고
4. foo함수는 error를 throw한다.

이 때 해당 error 객체는 다음과 같이 여행을 해서 최종적으로 전역 컨텍스트에서 `catch`된다.

- foo 실행 컨텍스트 → bar 실행 컨텍스트 → baz 실행 컨텍스트 → 전역 실행 컨텍스트
- 이 처럼 `throw`된 에러를 따로 `catch`하지 않으면 계속해서 호출자 방향으로 전파된다.
- 여기서 적절하게 에러를 `catch`를 해서 대응을 해주면, 프로그램은 종료되지 않고 계속 실행될 수 있는 것이다.